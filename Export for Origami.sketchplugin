// (ctrl alt cmd O)
// Export for Origami v1.0 - Julius Tarng
// Based on bomberstudio's sketch-framer, GeertWille's sketch-export-assets and zmaltalker's sketch-android-assets
// - Exports all layers and flattened groups (append name with *) similar to sketch-framer plugin
// - Saves all assets to path of current document + origami/ + <artboardname>/ + <layername>.png

preflight(); // Checks version + if file is saved. Must be at top!
var origami_directory = "/" + [doc displayName] + " Origami Project",
    export_directory = [[doc fileURL] path].split([doc displayName])[0] + origami_directory,
    export_scale_factor = 1,
    layer_names = [], // to prevent conflicting filenames
    settings_filepath = export_directory + "/.origamiblueprint",
    settings = [[NSMutableDictionary alloc] init]; // for .origamiblueprint file
main();

//
// Main export functions
//

function main() {
  log("========================= Export for Origami log =========================");

  var layers = [[doc currentPage] layers],
      artboard_name,
      fileManager = [NSFileManager defaultManager],
      origami_settings_exists = [fileManager fileExistsAtPath:settings_filepath];

  if (origami_settings_exists) { 
    var data = [[NSString stringWithContentsOfFile:settings_filepath] dataUsingEncoding:NSUTF8StringEncoding];
    settings = [NSJSONSerialization JSONObjectWithData:data options:0 error:nil];
    export_scale_factor = [settings valueForKeyPath:@"scale"];
  } else {
    var factors = [".5x", "1x", "1.5x", "2x", "3x"];
    var scale_factor_choice = combobox("Export with what resolution multiplier?", factors, 1);
    export_scale_factor = scale_factor_choice[2].replace(/([A-Za-z])/g,"");
  }

  for (var i=0; i<[layers count]; i++) {
    var layer = [layers objectAtIndex:i];
    if([layer isMemberOfClass:[MSArtboardGroup class]]){
      artboard_name = [layer name];
    } else {
      artboard_name = "";
    }
    process_layer(layer, 0, artboard_name);
  }

  if (origami_settings_exists) {
    [doc showMessage:"Updating " + layer_names.length + " assets for Origami"];
  } else {
    [doc showMessage:"Creating folder with " + layer_names.length + " assets for Origami"];
    [settings setValue:export_scale_factor forKey:@"scale"];
    var scaleJSON = [NSJSONSerialization dataWithJSONObject:settings options:NSJSONWritingPrettyPrinted error:nil];
    scaleJSON = [[NSString alloc] initWithData:scaleJSON encoding:NSUTF8StringEncoding];
    log("Making .origamiblueprint file with contents: " + scaleJSON);
    [scaleJSON writeToFile:settings_filepath atomically:true encoding:NSUTF8StringEncoding error:null];
  }

  
  // Open folder in Finder
  var finder_task = [[NSTask alloc] init],
  open_finder_args = [NSArray arrayWithObjects:"-R", export_directory, nil];
  [finder_task setLaunchPath:"/usr/bin/open"];
  [finder_task setArguments:open_finder_args];
  [finder_task launch];
}

function process_layer(layer, depth, artboard_name) {
  // Ignore MSPage layers
  if (should_ignore_layer(layer)) {
    log_depth("Ignoring <" + [layer name] + "> of type <" + [layer className] + ">", depth);
    return;
  }

  // Process groups (including artboards) and layers marked with +, and ungrouped layers outside of artboards
  if (should_export_layer(layer) || (!is_group(layer) && (depth == 0))) {
    if (array_contains(layer_names, artboard_name + [layer name])) {
      log_depth("Layer name conflict: <" + [layer name] + "> already exists in artboard <" + artboard_name + ">", depth);
      alert((artboard_name.length > 0 ? "" : "This name is taken by another group/layer in artboard '" + artboard_name) +
            "'.\n\nPlease make sure all exportable groups/layers have unique names.", "Layer name conflict: '" + [layer name] + "'");
      [layer select:true byExpandingSelection:false];
      return;
    } else {
      layer_names.push(artboard_name + [layer name]);
    }

    if (![layer isVisible]) {
      // TODO: Support hidden layers?
      return;
    }

    // Recursively go through sublayers if group not flattened with *
    if (is_unflattened_group(layer)) {
      var sublayers = [layer layers];
      // Sketch returns sublayers in reverse, so we'll iterate backwards
      for (var sub=([sublayers count] - 1); sub >= 0; sub--) {
        var current = [sublayers objectAtIndex:sub];
        process_layer(current, depth+1, artboard_name);
      }
    }

    export_layer(layer, depth, artboard_name);
  }
}

function export_layer(layer, depth, artboard_name) {
  // Copy off-screen, out of artboard so it is not masked by artboard
  var layer_copy = [layer duplicate];
  [layer_copy removeFromParent];
  [[doc currentPage] addLayers: [layer_copy]];
  var frame = [layer_copy frame];
  [frame setX: -100000];
  [frame setY: -100000];

  var included_layers = [];
  var has_art = false;
  var mask_layer;

  log_depth("Processing <" + [layer name] + "> of type <" + [layer className] + ">", depth);

  if (is_group(layer)) {
    var sublayers = [layer_copy layers];

    for (var sub = ([sublayers count] - 1); sub >= 0; sub--) {
      var sublayer = [sublayers objectAtIndex:sub];

      if ([sublayer hasClippingMask]) {
        // Bc of reverse layer order, first mask is the bottom-most
        log_depth_core("Masking with <" + [sublayer name] + ">", depth, " ");
        mask_layer = sublayer;
      }

      // if sublayer should be exported on its own
      if(should_export_layer(sublayer)) {
        log_depth_core("Removing <" + [sublayer name] + ">", depth, " ");
        [sublayer removeFromParent];
      } else {
        log_depth_core("Keeping <" + [sublayer name] + ">", depth, " ");
        included_layers.push([sublayer name]);
        has_art = true;
      }
    }
  } else {
    has_art = true;
  }

  if (has_art) {
    if (artboard_name !== "") {
      artboard_name = "/" + sanitize_filename(artboard_name);
    }
    var filename = artboard_name + "/" + sanitize_filename([layer name]) + ".png";
    log_depth("Exporting <" + filename + "> including sublayers (" + included_layers.join(", ") + ")", depth);

    // Export slice
    var rect;
    if (mask_layer) {
      rect = [mask_layer absoluteDirtyRect];
    } else {
      rect = [layer_copy absoluteDirtyRect];
    }
    
    var slice = [MSExportRequest requestWithRect:rect scale:export_scale_factor];

    [doc saveArtboardOrSlice:slice toFile:export_directory + filename];
  } else {
    log_depth("Did not export <" + [layer name] + ">, no image", depth);
  }

  // Remove copy
  [layer_copy removeFromParent];
}

//
// Helpers
//

function preflight() { 
  var app_version = [NSApp applicationVersion].substr(0,1);
  if (app_version < 3) {
    alert("Export for Origami only supports Sketch 3 and above. You are running " + app_version, "Please upgrade Sketch");
    return;
  }

  if ([doc fileURL] == null) {
    alert("Please save your document. Export for Origami will export the assets to the same folder under " + origami_directory, "Unsaved document");
    return;
  }
}

function combobox(msg, items, selectedItemIndex){
  selectedItemIndex = selectedItemIndex || 0;

  var combobox = [[NSComboBox alloc] initWithFrame:NSMakeRect(0,0,50,25)];
  [combobox addItemsWithObjectValues:items];
  [combobox selectItemAtIndex:selectedItemIndex];

  var alert = [[NSAlert alloc] init];
  [alert setMessageText:msg];
  [alert addButtonWithTitle:'Save'];
  [alert addButtonWithTitle:'Cancel'];
  [alert setAccessoryView:combobox];

  var responseCode = [alert runModal];
  var combosel = [combobox indexOfSelectedItem];
  var combovalue = [combobox stringValue];
  log(combovalue);

  return [responseCode, combosel, combovalue];
}

//
// Layer Helpers
//
    
function should_ignore_layer(layer) {
  return [layer name].slice(-1) == "-";
}

function should_flatten_layer(layer) {
  if([layer name].slice(-1) == "*") {
    return true;
  } else {
    return false;
  }
}

// Export all groups and layers appended with +
function should_export_layer(layer) {
  return is_group(layer) || [layer name].slice(-1) == '+';
}

function is_group(layer) {
  return [layer isMemberOfClass:[MSLayerGroup class]] || [layer isMemberOfClass:[MSArtboardGroup class]]
}

function is_unflattened_group(layer) {
  return is_group(layer) && !should_flatten_layer(layer);
}

//
// File helpers
//

function prompt_for_directory() {
    var panel = [NSOpenPanel openPanel];
    [panel setMessage:"Where do you want to place your assets?"];
    [panel setCanChooseDirectories: true];
    [panel setCanChooseFiles: false];
    [panel setCanCreateDirectories: true];
    var default_dir = [[doc fileURL] URLByDeletingLastPathComponent];
    [panel setDirectoryURL:default_dir];

    if ([panel runModal] == NSOKButton){
      var message = [panel filename];
      return message;
    }
}

function sanitize_filename(name) {
  return name.replace(/(:|\/)/g ,"_").replace(/__/g,"_").replace("*","").replace("+","").replace("@@hidden",""); // TODO: replace spaces? /(\s|:|\/)/g
}

//
// Debug Helpers
//

function alert(msg, title){
  var app = [NSApplication sharedApplication];
  [app displayDialog:msg withTitle:title];
}

function log_depth(message, depth) {
  log_depth_core(message, depth, ">");
}

function log_depth_core(message, depth, spacer) {
  var padding = spacer;
  for(var i=0; i<depth; i++) {
    padding = padding + spacer;
  }
  log(padding + " " + message);
}

function array_contains(array, object) {
  for (i=0;i<array.length;i++) {
    if (array[i] == object) {
      return true;
    }
  }

  return false;
}